"""
ASL Sign Language Recognition - Step 3: Convert Model to Arduino C++ Code
Uses micromlgen to convert the trained model to C++ code for Arduino deployment
"""

import pickle
import numpy as np
import pandas as pd
import os
from micromlgen import port

MODEL_FILE = "output/asl_model.pkl"
ARDUINO_OUTPUT_FILE = "output/asl_model.h"
ARDUINO_SKETCH_FILE = "output/asl_recognition_arduino.ino"

def print_section(title):
    print(f"\n{'='*60}")
    print(f"{title}")
    print(f"{'='*60}")

if __name__ == "__main__":
    print_section("ASL Model to Arduino C++ Converter")
    
    print(f"\nLoading trained model from: {MODEL_FILE}")
    
    if not os.path.exists(MODEL_FILE):
        print(f"\nERROR: {MODEL_FILE} not found!")
        print("   Please run 2_train_model.py first")
        exit(1)
    
    with open(MODEL_FILE, 'rb') as f:
        model = pickle.load(f)
    
    print(f"Model loaded successfully")
    print(f"   Model type: {type(model).__name__}")
    print(f"   Number of estimators: {model.n_estimators}")
    print(f"   Max depth: {model.max_depth}")
    print(f"   Number of features: {model.n_features_in_}")
    
    print_section("Converting Model to C++ Code")
    
    print("Generating C++ code using micromlgen...")
    print("This may take a moment...\n")
    
    try:
        cpp_code = port(model, classmap={
            0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E', 5: 'F', 
            6: 'G', 7: 'H', 8: 'I', 9: 'J', 10: 'K', 11: 'L',
            12: 'M', 13: 'N', 14: 'O', 15: 'P', 16: 'Q', 17: 'R',
            18: 'S', 19: 'T', 20: 'U', 21: 'V', 22: 'W', 23: 'X',
            24: 'Y', 25: 'Z'
        })
        
        print("Conversion successful!")
        code_size = len(cpp_code) / 1024
        print(f"   Estimated code size: {code_size:.2f} KB")
        
    except Exception as e:
        print(f"\nERROR during conversion: {e}")
        print("\nTroubleshooting tips:")
        print("   1. Try reducing n_estimators in 2_train_model.py")
        print("   2. Try reducing max_depth in 2_train_model.py")
        print("   3. Ensure model is a RandomForestClassifier")
        exit(1)
    
    print_section("Creating Arduino Header File")
    
    header_content = f"""/*
 * ASL Sign Language Recognition Model
 * Auto-generated by micromlgen
 * 
 * Model Details:
 * - Input features: 63 (21 landmarks x 3 coordinates)
 * - Output classes: 26 (A-Z)
 * - Model type: Random Forest Classifier
 * - Estimators: {model.n_estimators}
 * - Max depth: {model.max_depth}
 */

#ifndef ASL_MODEL_H
#define ASL_MODEL_H

{cpp_code}

#endif // ASL_MODEL_H
"""
    
    os.makedirs(os.path.dirname(ARDUINO_OUTPUT_FILE), exist_ok=True)
    with open(ARDUINO_OUTPUT_FILE, 'w') as f:
        f.write(header_content)
    
    file_size_kb = os.path.getsize(ARDUINO_OUTPUT_FILE) / 1024
    print(f"Header file created: {ARDUINO_OUTPUT_FILE}")
    print(f"   File size: {file_size_kb:.2f} KB")
    
    print_section("Creating Arduino Sketch Template")
    
    arduino_sketch = """/*
 * ASL Sign Language Recognition - Arduino Sketch
 * For Arduino Nano 33 BLE Sense (or compatible boards)
 */

#include "asl_model.h"

const int LED_PIN = LED_BUILTIN;
const int BUFFER_SIZE = 63;
float features[BUFFER_SIZE];

void setup() {
  Serial.begin(115200);
  while (!Serial);
  
  pinMode(LED_PIN, OUTPUT);
  
  Serial.println("====================================");
  Serial.println("ASL Sign Language Recognition");
  Serial.println("====================================");
  Serial.println();
  Serial.println("Model loaded and ready!");
  Serial.println("Waiting for hand landmark data...");
  Serial.println();
  
  for (int i = 0; i < 3; i++) {
    digitalWrite(LED_PIN, HIGH);
    delay(200);
    digitalWrite(LED_PIN, LOW);
    delay(200);
  }
}

void loop() {
  if (Serial.available() > 0) {
    String input = Serial.readStringUntil('\\n');
    
    if (input.startsWith("LANDMARKS:")) {
      input.remove(0, 10);
      int index = 0;
      int lastComma = -1;
      
      for (int i = 0; i <= input.length() && index < BUFFER_SIZE; i++) {
        if (i == input.length() || input.charAt(i) == ',') {
          String value = input.substring(lastComma + 1, i);
          features[index++] = value.toFloat();
          lastComma = i;
        }
      }
      
      if (index == BUFFER_SIZE) {
        char prediction = predict(features);
        
        Serial.print("Prediction: ");
        Serial.println(prediction);
        
        digitalWrite(LED_PIN, HIGH);
        delay(100);
        digitalWrite(LED_PIN, LOW);
      } else {
        Serial.println("ERROR: Invalid number of features");
      }
    }
  }
  
  delay(100);
}

char predict(float* input) {
  int classIndex = classifyFeaturesIndex(input);
  return 'A' + classIndex;
}
"""
    
    with open(ARDUINO_SKETCH_FILE, 'w') as f:
        f.write(arduino_sketch)
    
    sketch_size_kb = os.path.getsize(ARDUINO_SKETCH_FILE) / 1024
    print(f"Arduino sketch created: {ARDUINO_SKETCH_FILE}")
    print(f"   File size: {sketch_size_kb:.2f} KB")
    
    print_section("Arduino Deployment Analysis")
    
    ARDUINO_FLASH_KB = 1000
    ARDUINO_RAM_KB = 256
    BUFFER_SIZE = 63
    
    estimated_flash = file_size_kb + sketch_size_kb + 50
    estimated_ram = 10 + (BUFFER_SIZE * 4 / 1024)
    
    print(f"\nResource Estimates:")
    print(f"   Flash Usage: ~{estimated_flash:.1f} KB / {ARDUINO_FLASH_KB} KB ({estimated_flash/ARDUINO_FLASH_KB*100:.1f}%)")
    print(f"   RAM Usage: ~{estimated_ram:.1f} KB / {ARDUINO_RAM_KB} KB ({estimated_ram/ARDUINO_RAM_KB*100:.1f}%)")
    print()
    
    if estimated_flash < ARDUINO_FLASH_KB * 0.8:
        print("Flash: Excellent fit!")
    elif estimated_flash < ARDUINO_FLASH_KB:
        print("Flash: Tight fit, but should work")
    else:
        print("Flash: Too large! Reduce model complexity")
    
    if estimated_ram < ARDUINO_RAM_KB * 0.5:
        print("RAM: Plenty of headroom")
    elif estimated_ram < ARDUINO_RAM_KB * 0.8:
        print("RAM: Should work, but monitor usage")
    else:
        print("RAM: May have memory issues")
    
    print_section("Creating Python Test Script")
    
    test_script = '''"""Test script to send landmarks to Arduino via Serial"""

import serial
import time
import pandas as pd

SERIAL_PORT = 'COM3'
BAUD_RATE = 115200
TEST_CSV = "output/asl_features.csv"

def send_landmarks_to_arduino(ser, landmarks):
    landmark_str = "LANDMARKS:" + ",".join([str(x) for x in landmarks])
    ser.write((landmark_str + "\\n").encode())
    time.sleep(0.1)
    
    if ser.in_waiting:
        response = ser.readline().decode().strip()
        return response
    return None

def test_with_dataset():
    print("Loading test dataset...")
    df = pd.read_csv(TEST_CSV)
    
    print(f"Attempting to connect to Arduino on {SERIAL_PORT}...")
    try:
        ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=1)
        time.sleep(2)
        print("Connected to Arduino\\n")
        
        samples = df.sample(n=min(10, len(df)))
        
        print("Testing predictions:\\n")
        correct = 0
        total = 0
        
        for idx, row in samples.iterrows():
            features = row[:-1].values
            true_label = row.iloc[-1]
            
            response = send_landmarks_to_arduino(ser, features)
            
            if response and "Prediction:" in response:
                predicted = response.split("Prediction:")[1].strip()
                is_correct = predicted == true_label
                correct += is_correct
                total += 1
                
                status = "OK" if is_correct else "FAIL"
                print(f"{status} True: {true_label}, Predicted: {predicted}")
            else:
                print(f"WARNING: No response from Arduino")
            
            time.sleep(0.5)
        
        print(f"\\nAccuracy: {correct}/{total} ({correct/total*100:.1f}%)")
        
        ser.close()
        print("\\nTest complete!")
        
    except Exception as e:
        print(f"ERROR: {e}")
        print("\\nTroubleshooting:")
        print("1. Check that Arduino is connected")
        print("2. Verify the correct port")
        print("3. Close Arduino IDE Serial Monitor if open")
        print("4. Install pyserial: pip install pyserial")

if __name__ == "__main__":
    test_with_dataset()
'''
    
    with open("output/test_arduino_serial.py", 'w') as f:
        f.write(test_script)
    
    print(f"Test script created: output/test_arduino_serial.py")
    
    print_section("Conversion Complete!")
    
    print(f"""
Arduino conversion successful!

Generated Files:
   1. {ARDUINO_OUTPUT_FILE} ({file_size_kb:.2f} KB)
   2. {ARDUINO_SKETCH_FILE} ({sketch_size_kb:.2f} KB)
   3. output/test_arduino_serial.py

Next Steps:

1. Arduino Setup:
   a. Open Arduino IDE
   b. Create new sketch folder: "ASL_Recognition"
   c. Copy {ARDUINO_OUTPUT_FILE} to sketch folder
   d. Copy {ARDUINO_SKETCH_FILE} to sketch folder
   e. Connect Arduino and upload

2. Testing:
   a. Open Serial Monitor (115200 baud)
   b. Run: python output/test_arduino_serial.py
   c. Adjust SERIAL_PORT in test script as needed

All steps complete! Your ASL model is ready for Arduino!
""")
    
    print("="*60)
